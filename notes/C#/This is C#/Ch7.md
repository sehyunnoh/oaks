# 7.1 객체 지향 프로그래밍과 클래스 
- 코드 내의 모든 것을 객체로 표현하려는 프로그래밍 패러다임
  - 객체(object) : 세상의 모든 것을 지칭
- 객체의 표현
  - 속성: 데이터
  - 기능: 메서드
- 클래스 : 객체를 만들기 위한 청사진
- int a = 30;
  - int : 클래스, 청사진
  - a: 객체, int의 실체(instance)

# 7.2 클래스의 선언과 객체의 생성
- 클래스의 선언 형식
```c#
class 이름
{
    // 데이터와 메서드
}
```
- 클래스의 선언과 사용 예

`sample code : BasicClass` 

# 7.3 객체의 삶과 죽음에 대하여: 생성자와 종료자
- 객체의 삶과 죽음을 관장하는 두 가지 메서드
- 객체를 만드는 생성자
- 객체를 파괴하는 종료자
# 7.3.1 생성자
- 클래스와 같은 이름, 반환 형식 없음
- 선언 형식
- 기본 생성자
- 사용자 지정 생성자 (매개변수 넣어서)
# 7.3.2 종료자
- 클래스 이름 앞에 ~를 붙인 꼴
- 매개변수도 없고, 한정자도 사용하지 않음
- 오버로딩 불가능, 직접 호출 할수 없음
- 종료자는 사용하지 말자
  - CLR의 가비지 컬렉터의 동작 시점 예측 불가능
  - 명시적 종료자 구현은 성능 저하 초래 가능성 높음
  - CLR의 가비지 컬렉터는 객체 소멸 처리 전문가다. gc에 맡기는게 낳음   

` sample source : Constructor`

# 7.4 정적 필드와 메소드
- static 은 메소드나 필드가 클래스 자체에 소속되도록 지정하는 한정자
  - 프로그램 전체에 공유하는 변수에 사용  

`sample source : StaticField`
- 정적 메소드는 클래스 자체에 소속됨
  - 클래스 인스턴스 생성 없이도 호출 가능
- 인스턴스 생성이 필요한 메서드
  -  인스턴스 메서드, 객체 내부의 데이터 이용

# 7.5 객체 복사하기: 얕은 복사와 깊은 복사 
- 얕은 복사
  - 객체를 복사할 때 참조만 살짝 복사 (같은 데이터 가르킴)
- 깊은 복사
  - 별도의 힙 공간에 객체 자체 복사

`sample source: DeepCopy`

# 7.6 this
- 객체가 자신을 지칭할 때 사용하는 키워드 this
  - 객체 내부에서 자신의 필드나 메소드에 접근할 때 사용

`sample source: This`
- this() 생성자

`sample source: ThisConstructor`

# 7.7 접근 한정자로 공개 수준 결정하기 
- 은닉성(캡슐화)의 구현
  - 감추고 싶은 것은 감추고, 보여주고 싶은 것만 보여준다
- 접근 한정자의 종류
  - public
  - protected
  - private (default)
  - internal
  - protected internal
  - private protected

`sample source: AccessModifier`  

# 7.8 상속으로 코드 재활용하기(1)
- 물려받는 클래스가 물려줄 클래스 지정
- 상속의 형식
- 파생 클래스의 수명 주기
  - 기반 생성자 -> 파생 생성자 -> 파생 종료자 -> 기반 종료자
- 기반 클래스의 멤버 호출 -> base
  - 파생 클래스의 생성자에서 기반 클래스 생성자에 매개변수 전달

`sample source: Inheritance`  

# 7.9 기반 클래스와 파생 클래스 사이의 형식 변환
- 기반 클래스와 파생 클래스 사이에 족보를 오르내리는 형식 변환이 가능
- 파생 클래스의 인스턴스를 기반 클래스의 인스턴스로 사용 가능

# 7.9 is 와 as
- is : 객체가 해당 형식에 해당하는지를 검사하여 그 결과를 bool 값으로 반환 
- as : 형식 변환 연산자와 같은 역할을 합니다. 다만 형변환 연산자가 변환에 실패하는 경우 예외를 던지는 반면에 as 연산자는 객체 참조를 null로 만든다는 것이 다름. (참조형식에서만 사용함)

`sample source: TypeCasting`